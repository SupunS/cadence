/*
 * Cadence - The resource-oriented smart contract programming language
 *
 * Copyright 2019-2020 Dapper Labs, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"fmt"
	"os"
	"reflect"
	"regexp"
	"strings"
	"text/template"
)

const fileTemplate = `// Code generated by utils/version. DO NOT EDIT.
/*
 * Cadence - The resource-oriented smart contract programming language
 *
 * Copyright 2019-2020 Dapper Labs, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//go:generate go run ./gen/main.go

package wasm

import (
	"io"
)

{{range .Instructions -}}
// Instruction{{.Identifier}} is the '{{.Name}}' instruction
//
type Instruction{{.Identifier}} struct {{if .Arguments}}{
{{- range .Arguments}}
	{{.Identifier}} {{.Type}}{{end}}
}
{{- else}}{}{{- end}}

func (i Instruction{{.Identifier}}) write(wasm *WASMWriter) error {
	err := wasm.writeOpcode({{.OpcodeList}})
	if err != nil {
		return err
	}
{{- range .Arguments}}

	err = {{.Write}}
	if err != nil {
		return err
	}
{{- end}}
	return nil
}

{{end -}}

const (
{{- range .Instructions }}
	// {{.OpcodeIdentifier}} is the opcode for the '{{.Name}}' instruction
	{{.OpcodeIdentifier}} opcode = {{.Opcode | printf "0x%x"}}
{{- end}}
)

// readInstruction reads an instruction in the WASM binary
//
func readInstruction(buf *buf) (Instruction, error) {
	opcodeOffset := buf.offset
	b, err := buf.ReadByte()

	c := opcode(b)

	readUint32LEB128 := func() (uint32, error) {
		offset := buf.offset
		v, err := buf.readUint32LEB128()
		if err != nil {
			return 0, InvalidInstructionArgumentError{
				Offset:    int(offset),
				Opcode:    c,
				ReadError: err,
			}
		}
		return v, nil
	}

	if err != nil {
		if err == io.EOF {
			return nil, MissingEndInstructionError{
				Offset: int(opcodeOffset),
			}
		} else {
			return nil, InvalidOpcodeError{
				Offset:    int(opcodeOffset),
				Opcode:    c,
				ReadError: err,
			}
		}
	}
{{switch .}}
}
`

const switchTemplate = `
switch c {
{{- range $key, $group := . }}
case {{ $key }}:
{{- if (eq (len $group.Instructions) 1)}}
{{- with (index $group.Instructions 0) }}
{{- range .Arguments}}
	{{.Variable}}, err := {{.Read}}()
	if err != nil {
		return nil, err
	}
{{end}}
	return Instruction{{.Identifier}}{{if .Arguments}}{
{{- range .Arguments}}
		{{.Identifier}}: {{.Variable}},{{end}}
	}
{{- else}}{}{{- end}}, nil
{{end}}
{{- else}}
{{switch $group}}
{{- end}}{{end}}
default:
	return nil, InvalidOpcodeError{
		Offset:    int(opcodeOffset),
		Opcode:    c,
		ReadError: err,
	}
}
`

type opcodes []byte

type argument struct {
	Identifier string
	Type       reflect.Kind
}

func (a argument) Write() (string, error) {
	switch a.Type {
	case reflect.Uint32:
		return fmt.Sprintf("wasm.buf.writeUint32LEB128(i.%s)", a.Identifier), nil
	}
	return "", fmt.Errorf("invalid argument type: %s", a.Type)
}

func (a argument) Read() (string, error) {
	switch a.Type {
	case reflect.Uint32:
		return "readUint32LEB128", nil
	}
	return "", fmt.Errorf("invalid argument type: %s", a.Type)
}

func (a argument) Variable() string {
	first := strings.ToLower(string(a.Identifier[0]))
	rest := a.Identifier[1:]
	return first + rest
}

type arguments []argument

type instruction struct {
	Name      string
	Opcodes   opcodes
	Arguments arguments
}

var identifierPartRegexp = regexp.MustCompile("(^|[._])[A-Za-z0-9]")

func (ins instruction) Identifier() string {
	return string(identifierPartRegexp.ReplaceAllFunc([]byte(ins.Name), func(bytes []byte) []byte {
		return []byte(strings.ToUpper(string(bytes[len(bytes)-1])))
	}))
}
func (ins instruction) OpcodeList() string {
	var b strings.Builder

	count := len(ins.Opcodes)

	// prefix
	for i := 0; i < count-1; i++ {
		if i > 0 {
			b.WriteString(", ")
		}
		opcode := ins.Opcodes[i]
		_, err := fmt.Fprintf(&b, "0x%x", opcode)
		if err != nil {
			panic(err)
		}
	}

	// final opcode
	if count > 1 {
		b.WriteString(", ")
	}
	_, err := b.WriteString(ins.OpcodeIdentifier())
	if err != nil {
		panic(err)
	}

	return b.String()
}

func (ins instruction) Opcode() byte {
	return ins.Opcodes[len(ins.Opcodes)-1]
}

func (ins instruction) OpcodeIdentifier() string {
	return fmt.Sprintf("opcode%s", ins.Identifier())
}

type instructionGroup struct {
	Depth        int
	Instructions []instruction
}

func (group instructionGroup) GroupByOpcode() map[string]instructionGroup {
	result := map[string]instructionGroup{}

	for _, ins := range group.Instructions {
		innerDepth := group.Depth + 1
		atEnd := len(ins.Opcodes) <= innerDepth
		opcode := ins.Opcodes[group.Depth]
		var key string
		if atEnd {
			key = ins.OpcodeIdentifier()
		} else {
			key = fmt.Sprintf("0x%x", opcode)
		}
		innerGroup := result[key]
		innerGroup.Depth = innerDepth
		innerGroup.Instructions = append(innerGroup.Instructions, ins)
		result[key] = innerGroup
	}

	return result
}

var trailingWhitespaceRegexp = regexp.MustCompile("(?m:[ \t]+$)")

const target = "instructions.go"

func main() {

	f, err := os.Create(target)
	if err != nil {
		panic(fmt.Errorf("could not create %s: %w\n", target, err))
	}
	defer func() {
		_ = f.Close()
	}()

	var generateSwitch func(group instructionGroup) (string, error)

	templateFuncs := map[string]interface{}{
		"switch": func(group instructionGroup) (string, error) {
			res, err := generateSwitch(group)
			if err != nil {
				return "", err
			}
			pad := strings.Repeat("\t", group.Depth+1)
			padded := pad + strings.Replace(res, "\n", "\n"+pad, -1)
			trimmed := trailingWhitespaceRegexp.ReplaceAll([]byte(padded), nil)
			return string(trimmed), nil
		},
	}

	parsedSwitchTemplate := template.Must(
		template.New("switch").
			Funcs(templateFuncs).
			Parse(switchTemplate),
	)

	parsedFileTemplate := template.Must(
		template.New("instructions").
			Funcs(templateFuncs).
			Parse(fileTemplate),
	)

	generateSwitch = func(instructions instructionGroup) (string, error) {
		var b strings.Builder
		err := parsedSwitchTemplate.Execute(&b, instructions.GroupByOpcode())
		if err != nil {
			return "", err
		}
		return b.String(), nil
	}

	declare := func(instructions []instruction) {
		err = parsedFileTemplate.Execute(f,
			instructionGroup{
				Depth:        0,
				Instructions: instructions,
			},
		)
		if err != nil {
			panic(err)
		}
	}

	declare([]instruction{
		// Control Instructions
		{"unreachable", opcodes{0x0}, arguments{}},
		{"nop", opcodes{0x01}, arguments{}},
		{"end", opcodes{0x0B}, arguments{}},
		{"br", opcodes{0x0C}, arguments{{"Index", reflect.Uint32}}},
		{"br_if", opcodes{0x0D}, arguments{{"Index", reflect.Uint32}}},
		{"return", opcodes{0x0F}, arguments{}},
		{"call", opcodes{0x10}, arguments{{"FuncIndex", reflect.Uint32}}},
		{"call_indirect", opcodes{0x11}, arguments{{"TypeIndex", reflect.Uint32}, {"TableIndex", reflect.Uint32}}},
		// Parametric Instructions
		{"drop", opcodes{0x1A}, arguments{}},
		{"select", opcodes{0x1B}, arguments{}},
		// Variable Instructions
		{"local.get", opcodes{0x20}, arguments{{"LocalIndex", reflect.Uint32}}},
		{"local.set", opcodes{0x21}, arguments{{"LocalIndex", reflect.Uint32}}},
		{"local.tee", opcodes{0x22}, arguments{{"LocalIndex", reflect.Uint32}}},
		{"global.get", opcodes{0x23}, arguments{{"GlobalIndex", reflect.Uint32}}},
		{"global.set", opcodes{0x24}, arguments{{"GlobalIndex", reflect.Uint32}}},
		// Numeric Instructions
		{"i32.add", opcodes{0x6a}, arguments{}},
	})
}
