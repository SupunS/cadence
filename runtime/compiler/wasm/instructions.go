// Code generated by utils/version. DO NOT EDIT.
/*
 * Cadence - The resource-oriented smart contract programming language
 *
 * Copyright 2019-2020 Dapper Labs, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//go:generate go run ./gen/main.go

package wasm

import (
	"io"
)

// InstructionUnreachable is the 'unreachable' instruction
//
type InstructionUnreachable struct {}

func (i InstructionUnreachable) write(wasm *WASMWriter) error {
	err := wasm.writeOpcode(opcodeUnreachable)
	if err != nil {
		return err
	}
	return nil
}

// InstructionNop is the 'nop' instruction
//
type InstructionNop struct {}

func (i InstructionNop) write(wasm *WASMWriter) error {
	err := wasm.writeOpcode(opcodeNop)
	if err != nil {
		return err
	}
	return nil
}

// InstructionEnd is the 'end' instruction
//
type InstructionEnd struct {}

func (i InstructionEnd) write(wasm *WASMWriter) error {
	err := wasm.writeOpcode(opcodeEnd)
	if err != nil {
		return err
	}
	return nil
}

// InstructionBr is the 'br' instruction
//
type InstructionBr struct {
	Index uint32
}

func (i InstructionBr) write(wasm *WASMWriter) error {
	err := wasm.writeOpcode(opcodeBr)
	if err != nil {
		return err
	}

	err = wasm.buf.writeUint32LEB128(i.Index)
	if err != nil {
		return err
	}
	return nil
}

// InstructionBrIf is the 'br_if' instruction
//
type InstructionBrIf struct {
	Index uint32
}

func (i InstructionBrIf) write(wasm *WASMWriter) error {
	err := wasm.writeOpcode(opcodeBrIf)
	if err != nil {
		return err
	}

	err = wasm.buf.writeUint32LEB128(i.Index)
	if err != nil {
		return err
	}
	return nil
}

// InstructionReturn is the 'return' instruction
//
type InstructionReturn struct {}

func (i InstructionReturn) write(wasm *WASMWriter) error {
	err := wasm.writeOpcode(opcodeReturn)
	if err != nil {
		return err
	}
	return nil
}

// InstructionCall is the 'call' instruction
//
type InstructionCall struct {
	FuncIndex uint32
}

func (i InstructionCall) write(wasm *WASMWriter) error {
	err := wasm.writeOpcode(opcodeCall)
	if err != nil {
		return err
	}

	err = wasm.buf.writeUint32LEB128(i.FuncIndex)
	if err != nil {
		return err
	}
	return nil
}

// InstructionCallIndirect is the 'call_indirect' instruction
//
type InstructionCallIndirect struct {
	TypeIndex uint32
	TableIndex uint32
}

func (i InstructionCallIndirect) write(wasm *WASMWriter) error {
	err := wasm.writeOpcode(opcodeCallIndirect)
	if err != nil {
		return err
	}

	err = wasm.buf.writeUint32LEB128(i.TypeIndex)
	if err != nil {
		return err
	}

	err = wasm.buf.writeUint32LEB128(i.TableIndex)
	if err != nil {
		return err
	}
	return nil
}

// InstructionDrop is the 'drop' instruction
//
type InstructionDrop struct {}

func (i InstructionDrop) write(wasm *WASMWriter) error {
	err := wasm.writeOpcode(opcodeDrop)
	if err != nil {
		return err
	}
	return nil
}

// InstructionSelect is the 'select' instruction
//
type InstructionSelect struct {}

func (i InstructionSelect) write(wasm *WASMWriter) error {
	err := wasm.writeOpcode(opcodeSelect)
	if err != nil {
		return err
	}
	return nil
}

// InstructionLocalGet is the 'local.get' instruction
//
type InstructionLocalGet struct {
	LocalIndex uint32
}

func (i InstructionLocalGet) write(wasm *WASMWriter) error {
	err := wasm.writeOpcode(opcodeLocalGet)
	if err != nil {
		return err
	}

	err = wasm.buf.writeUint32LEB128(i.LocalIndex)
	if err != nil {
		return err
	}
	return nil
}

// InstructionLocalSet is the 'local.set' instruction
//
type InstructionLocalSet struct {
	LocalIndex uint32
}

func (i InstructionLocalSet) write(wasm *WASMWriter) error {
	err := wasm.writeOpcode(opcodeLocalSet)
	if err != nil {
		return err
	}

	err = wasm.buf.writeUint32LEB128(i.LocalIndex)
	if err != nil {
		return err
	}
	return nil
}

// InstructionLocalTee is the 'local.tee' instruction
//
type InstructionLocalTee struct {
	LocalIndex uint32
}

func (i InstructionLocalTee) write(wasm *WASMWriter) error {
	err := wasm.writeOpcode(opcodeLocalTee)
	if err != nil {
		return err
	}

	err = wasm.buf.writeUint32LEB128(i.LocalIndex)
	if err != nil {
		return err
	}
	return nil
}

// InstructionGlobalGet is the 'global.get' instruction
//
type InstructionGlobalGet struct {
	GlobalIndex uint32
}

func (i InstructionGlobalGet) write(wasm *WASMWriter) error {
	err := wasm.writeOpcode(opcodeGlobalGet)
	if err != nil {
		return err
	}

	err = wasm.buf.writeUint32LEB128(i.GlobalIndex)
	if err != nil {
		return err
	}
	return nil
}

// InstructionGlobalSet is the 'global.set' instruction
//
type InstructionGlobalSet struct {
	GlobalIndex uint32
}

func (i InstructionGlobalSet) write(wasm *WASMWriter) error {
	err := wasm.writeOpcode(opcodeGlobalSet)
	if err != nil {
		return err
	}

	err = wasm.buf.writeUint32LEB128(i.GlobalIndex)
	if err != nil {
		return err
	}
	return nil
}

// InstructionI32Add is the 'i32.add' instruction
//
type InstructionI32Add struct {}

func (i InstructionI32Add) write(wasm *WASMWriter) error {
	err := wasm.writeOpcode(opcodeI32Add)
	if err != nil {
		return err
	}
	return nil
}

const (
	// opcodeUnreachable is the opcode for the 'unreachable' instruction
	opcodeUnreachable opcode = 0x0
	// opcodeNop is the opcode for the 'nop' instruction
	opcodeNop opcode = 0x1
	// opcodeEnd is the opcode for the 'end' instruction
	opcodeEnd opcode = 0xb
	// opcodeBr is the opcode for the 'br' instruction
	opcodeBr opcode = 0xc
	// opcodeBrIf is the opcode for the 'br_if' instruction
	opcodeBrIf opcode = 0xd
	// opcodeReturn is the opcode for the 'return' instruction
	opcodeReturn opcode = 0xf
	// opcodeCall is the opcode for the 'call' instruction
	opcodeCall opcode = 0x10
	// opcodeCallIndirect is the opcode for the 'call_indirect' instruction
	opcodeCallIndirect opcode = 0x11
	// opcodeDrop is the opcode for the 'drop' instruction
	opcodeDrop opcode = 0x1a
	// opcodeSelect is the opcode for the 'select' instruction
	opcodeSelect opcode = 0x1b
	// opcodeLocalGet is the opcode for the 'local.get' instruction
	opcodeLocalGet opcode = 0x20
	// opcodeLocalSet is the opcode for the 'local.set' instruction
	opcodeLocalSet opcode = 0x21
	// opcodeLocalTee is the opcode for the 'local.tee' instruction
	opcodeLocalTee opcode = 0x22
	// opcodeGlobalGet is the opcode for the 'global.get' instruction
	opcodeGlobalGet opcode = 0x23
	// opcodeGlobalSet is the opcode for the 'global.set' instruction
	opcodeGlobalSet opcode = 0x24
	// opcodeI32Add is the opcode for the 'i32.add' instruction
	opcodeI32Add opcode = 0x6a
)

// readInstruction reads an instruction in the WASM binary
//
func readInstruction(buf *buf) (Instruction, error) {
	opcodeOffset := buf.offset
	b, err := buf.ReadByte()

	c := opcode(b)

	readUint32LEB128 := func() (uint32, error) {
		offset := buf.offset
		v, err := buf.readUint32LEB128()
		if err != nil {
			return 0, InvalidInstructionArgumentError{
				Offset:    int(offset),
				Opcode:    c,
				ReadError: err,
			}
		}
		return v, nil
	}

	if err != nil {
		if err == io.EOF {
			return nil, MissingEndInstructionError{
				Offset: int(opcodeOffset),
			}
		} else {
			return nil, InvalidOpcodeError{
				Offset:    int(opcodeOffset),
				Opcode:    c,
				ReadError: err,
			}
		}
	}

	switch c {
	case opcodeBr:
		index, err := readUint32LEB128()
		if err != nil {
			return nil, err
		}

		return InstructionBr{
			Index: index,
		}, nil

	case opcodeBrIf:
		index, err := readUint32LEB128()
		if err != nil {
			return nil, err
		}

		return InstructionBrIf{
			Index: index,
		}, nil

	case opcodeCall:
		funcIndex, err := readUint32LEB128()
		if err != nil {
			return nil, err
		}

		return InstructionCall{
			FuncIndex: funcIndex,
		}, nil

	case opcodeCallIndirect:
		typeIndex, err := readUint32LEB128()
		if err != nil {
			return nil, err
		}

		tableIndex, err := readUint32LEB128()
		if err != nil {
			return nil, err
		}

		return InstructionCallIndirect{
			TypeIndex: typeIndex,
			TableIndex: tableIndex,
		}, nil

	case opcodeDrop:
		return InstructionDrop{}, nil

	case opcodeEnd:
		return InstructionEnd{}, nil

	case opcodeGlobalGet:
		globalIndex, err := readUint32LEB128()
		if err != nil {
			return nil, err
		}

		return InstructionGlobalGet{
			GlobalIndex: globalIndex,
		}, nil

	case opcodeGlobalSet:
		globalIndex, err := readUint32LEB128()
		if err != nil {
			return nil, err
		}

		return InstructionGlobalSet{
			GlobalIndex: globalIndex,
		}, nil

	case opcodeI32Add:
		return InstructionI32Add{}, nil

	case opcodeLocalGet:
		localIndex, err := readUint32LEB128()
		if err != nil {
			return nil, err
		}

		return InstructionLocalGet{
			LocalIndex: localIndex,
		}, nil

	case opcodeLocalSet:
		localIndex, err := readUint32LEB128()
		if err != nil {
			return nil, err
		}

		return InstructionLocalSet{
			LocalIndex: localIndex,
		}, nil

	case opcodeLocalTee:
		localIndex, err := readUint32LEB128()
		if err != nil {
			return nil, err
		}

		return InstructionLocalTee{
			LocalIndex: localIndex,
		}, nil

	case opcodeNop:
		return InstructionNop{}, nil

	case opcodeReturn:
		return InstructionReturn{}, nil

	case opcodeSelect:
		return InstructionSelect{}, nil

	case opcodeUnreachable:
		return InstructionUnreachable{}, nil

	default:
		return nil, InvalidOpcodeError{
			Offset:    int(opcodeOffset),
			Opcode:    c,
			ReadError: err,
		}
	}

}
